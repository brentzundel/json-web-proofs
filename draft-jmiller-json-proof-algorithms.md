%%%
title = "JSON Proof Algorithms"
abbrev = "jpa"
docName = "draft-jmiller-json-proof-algorithms-latest"
category = "info"
ipr = "none"
workgroup="todo"
keyword = ["jose", "zkp", "jwp", "jws", "jpa"]

[seriesInfo]
name = "Internet-Draft"
value = "draft-jmiller-json-proof-algorithms"
status = "standard"

[pi]
toc = "yes"

[[author]]
initials = "J."
surname = "Miller"
fullname = "Jeremie Miller"
organization = "Ping Identity"
  [author.address]
   email = "jmiller@pingidentity.com"

[[author]]
initials = "M."
surname = "Jones"
fullname = "Michael B. Jones"
organization = "Microsoft"
  [author.address]
  email = "mbj@microsoft.com"
  uri = "https://self-issued.info/"

%%%

.# Abstract

The JSON Proof Algorithms (JPA) specification registers cryptographic algorithms and identifiers to be used with the JSON Web Proof (JWP) and JSON Web Key (JWK) specifications. It defines several IANA registries for these identifiers.

{mainmatter}

# Introduction

The JSON Web Proof (JWP) draft establishes a new secure container format that supports selective disclosure and unlinkability using Zero-Knowledge Proofs (ZKPs) or other cryptographic algorithms.

# Conventions and Definitions

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
"SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this
document are to be interpreted as described in BCP 14 [@!RFC2119] [@RFC8174]
when, and only when, they appear in all capitals, as shown here.

The roles of "issuer", "holder", and "verifier", are used as defined by the [Verifiable Credentials Data Model v1.1](https://www.w3.org/TR/2021/REC-vc-data-model-20211109/).  The term "presentation" is also used as defined by this source, but the term "credential" is avoided in this specification in order to minimize confusion with other definitions.

# Terminology

The terms "JSON Web Signature (JWS)", "Base64url Encoding", "Header Parameter", "JOSE Header", "JWS Payload", "JWS Signature", and "JWS Protected Header" are defined by the JWS specification [JWS].

The terms "JSON Web Proof (JWP)", "JWP Payload", "JWP Proof", and "JWP Protected Header" are defined by the JWP specification [JWP].

These terms are defined by this specification:

Stable Key
  An asymmetric key-pair used by a issuer that is also shared via an out-of-band mechanism to a verifier in order to validate the signature.

Ephemeral Key
  An asymmetric key-pair that is generated for one-time use by a issuer and never stored or used again outside of the creation of a single JWP.

Replay Key
  An asymmetric key-pair that is generated by a holder and used to ensure a presentation is not able to be replayed by any other party.


# Background

JWP defines a container binding together a protected header, one or more payloads, and a cryptographic proof.  It does not define any details about the interactions between an application and the cryptographic libraries that implement proof-supporting algorithms.

Due to the nature of ZKPs, this specification also documents the subtle but important differences in proof algorithms versus those defined by the JSON Web Algorithms RFC.  These differences help support more advanced capabilities such as blinded signatures and predicate proofs.

# Algorithm Basics

The four principal interactions that every proof algorithm MUST support are `[issue](#issue)`, `[confirm](#confirm)`, `[present](#present)`, and `[verify](#verify)`.

## Issue

The JWP is first created as the output of a JPA's `issue` operation.

TODO:

* MUST support the issuer protected header as an octet string
* MUST support one or more payloads, each as an octet string
* MAY support algorithm-specific options from the holder (for blinded payloads, replay prevention, etc)
* MUST include integrity protection for the issuer header and all payloads
* MUST specify all digest and/or hash2curve methods used

## Confirm

Performed by the holder to validate the issued JWP is correctly formed and protected.

TODO:

* MAY support algorithm-specific options (such as those sent to the issuer)
* MAY return a modified JWP for serialized storage without the local state (such as with blinded payloads now un-blinded)
* MUST fully verify the proof value against the issuer protected header and all payloads
* MUST fail if given a presented JWP

## Present

Used to apply any selective disclosure choices and perform any unlinkability transformations.

TODO:

* MAY support algorithm-specific options from the requesting party (for predicate proofs and verifiable computation requests)
* MUST support the ability to hide any payload
* MUST always include the issuer protected header
* MUST replace the proof value
* MUST include a new presentation protected header that provides replay protection

## Verify

Performed by the verifier to verify the protected headers along with any revealed payloads and/or assertions about them from the proving party, while also verifying they are the same payloads and ordering as witnessed by the issuer.

TODO:

* MUST verify the integrity of all revealed payloads
* MUST verify the integrity of both the issuer and presentation protected headers
* MUST verify any included assertions about a hidden payload as true
* MAY support algorithm-specific options (such as those sent to the holder)
* Out of scope is the app interface to interact with the resulting verified assertions
* MUST fail if given only an issued JWP

# Algorithm Specifications

This section defines how to use specific algorithms for JWPs.

## Single Use

The Single Use (SU) algorithm is based on composing multiple traditional JWS values into a single JWP proof value.  It enables a very simple form of selective disclosure without requiring any advanced cryptographic techniques.

It does not support unlinkability if the same JWP is presented multiple times, therefore when privacy is required the holder will need to interact with the issuer again to receive new single-use JWPs (dynamically or in batches).

## JWS Algorithm

The Single Use algorithm is based on using multiple JWS values, all of which are generated with the same JSON Web Algorithm (JWA) for signing.  This JWA identifier is included as part of the Single Use identifier for JWP.

The chosen JWA MUST be an asymmetric signing algorithm so that each signature can be verified without sharing any private values between the parties.  This ensures that the verifier cannot brute-force any non-disclosed payloads based only on their disclosed individual signatures.

### Holder Setup

In order to support the protection of a presentation by a holder to a verifier, the holder MUST use a Replay Key during the issuance and the presentation of every Single Use JWP.  This Replay Key MUST be generated and used for only one JWP.

The issuer MUST verify that the holder has possession of this key.  The holder-issuer communication to exchange this information is out of scope of this specification, but can be easily accomplished by the holder using this key to generate a JWS that signs a value the issuer can verify as unique.

### Issuer Setup

To create a Single Use JWP the issuer first generates a unique Ephemeral Key using the selected JWS algorithm.  This key-pair will be used to sign each of the payloads of a single JWP and then discarded. 

### Using JWS

JSON Web Signatures are used to create all of the signature values used by the SU algorithm.  This allows an implementation to use an existing JWS library directly for all necessary cryptographic operations without requiring any additional primitives.

Each individual JWS uses a fixed protected header containing only the minimum required `alg` value.  Since this JWS protected header itself is the same for every JWS, it SHOULD be a static value in the form of `{"alg":"***"}` where `***` is the JWA asymmetric signing key algorithm identifier being used.  This value is re-created by a verifier using the correct JWA algorithm value included in the SU algorithm identifier.

If an implementation uses an alternative JWS protected header than this fixed value, a base64url encoded serialized form of the alternate fixed header MUST be included using the `jws_header` claim in the issuer protected header.

### Issuer Protected Header

The JWK of the issuer's Ephemeral Key MUST be included in the issuer protected header with the property name of `proof_jwk` and contain only the REQUIRED values to represent the public key.

The holder's Replay Key JWK MUST be included in issuer protected header using the `presentation_jwk` claim.

The final issuer protected header is then used directly as the body of a JWS and signed using the issuer's Stable Key.  The resulting JWS signature value unencoded octet string is the first value in the JWP proof.

### Payloads

Each JWP payload is processed in order and signed as a JWS body using the issuer's Ephemeral Key.  The resulting JWS signature value unencoded octet string is appended to the JWP proof.

The proof value as an octet string will have a total length that is the sum of the fixed length of the issuer protected header signature plus the fixed length of each of the payload Ephemeral Key signatures.  For example, the signature for the ES256 algorithm is 64 octets and for a JWP with five payloads the total proof value length would be `64 * (1 + 5) = 384` octets).

### Presentation Protected Header

In order to generate a new presentation, the holder first creates a presentation protected header that is specific to the verifier being presented to.  This header MUST contain a claim that both the holder and verifier trust as being unique and non-replay-able.

This specification registers a `nonce` claim for the presentation protected header that contains a string value either generated by the verifier or derived from values provided by the verifier.  When present, the verifier MUST ensure the nonce value matches during verification.

The presentation protected header MAY contain other claims that are either provided by the verifier or by the holder.  These presentation claims SHOULD NOT contain values that are common across multiple presentations and SHOULD be unique to a single presentation and verifier.

### Presentation

The holder derives a new proof value when presenting it to a verifier.  The presented proof value will always contain the issuer's Stable Key signature for the issuer protected header as the first element.

The second element of the presented proof value is always the holder's Replay Key signature of the presentation protected header, constructed identically to the issuer protected header by using the serialized JSON value octet string as the JWS body.  Signing only the presentation header with the Replay Key is sufficient to protect the entire presentation since that key is private to the holder and only the contents of the presentation header are used for replay prevention.

The two header signatures are then followed by only the issuer's Ephemeral Key signatures for each payload that is disclosed.  The order of the payload signatures is preserved and MUST be in the same order as the included disclosed payloads in the presented JWP.  Non-disclosed payloads will NOT have a signature value included.  For example, if the second and fifth payloads are hidden then the holder's derived proof value would be of the length `64 * (1 + 1 + the 1st, 2nd, and 4th payload signatures) = 320 octets`.

Since the individual signatures in the proof value are unique and remain unchanged across multiple presentations, a Single Use JWP SHOULD only be presented a single time to each verifier in order for the holder to remain unlinkable across multiple presentations.

### Verification

The verifier MUST verify the issuer protected header against the first matching JWS signature part in the proof value using the issuer's Stable Key.  It MUST also verify the presentation protected header against the second JWS signature part in the proof value using the holder's Replay Key as provided in the `presentation_jwk` claim in the issuer protected header.

With the headers verified, the issuer's Ephemeral Key as given in the issuer protected header `proof_jwk` claim can then be used to verify each of the disclosed payload signatures.

### JPA Registration

Proposed JWP `alg` value is of the format "SU-" appended with the relevant JWS `alg` value for the chosen public and ephemeral key-pair algorithm, for example "SU-ES256".

## BBS

The BBS Signature Scheme under active standards development as a [work item](https://github.com/decentralized-identity/bbs-signature) within the DIF [Applied Cryptography Working Group](https://identity.foundation/working-groups/crypto.html).  Prior to this effort, a [V1 implementation of BBS](https://github.com/mattrglobal/bbs-signatures) has been released and maintained by a community of individuals with notable adoption in multiple early stage decentralized identity projects.

This JSON Proof Algorithm definition for BBS is based on the already released implementation and relies on the provided software API.  A future definition with a different `alg` value will be created to succeed this version as the BBS standardization effort progresses.

This algorithm supports both selective disclosure and unlinkability, enabling the holder to generate multiple presentations from one issued JWP without any verifier being able to correlate those presentations together.

### BLS Curve

The pairing friendly elliptic curve used for the BBS software implementation is part of the BLS family with an embedding degree of 12 over a 381-bit prime field.  For this JPA, only the group G2 is used.

In the implementation the method used to generate the key pairs is `generateBls12381G2KeyPair()`.

### Messages

BBS is a multi-message scheme and operates on an array of individual messages for signing and proof generation.  Each message is a single binary octet string.  The BBS implementation uses a hash-to-curve method to map each message to a point.

### Issuer Protected Header

The UTF-8 octet string of the issuer protected header is the first message in the input array at index 0.

### Payloads

The octet strings of each payload are placed into the BBS message array following the issuer protected header message.  For example, first payload is at index 1 of the array and the last payload is always the last message in the array.

In future versions of this algorithm, there will be additional methods defined for transforming a payload into a point such that additional Zero-Knowledge Proof types can be supported by the holder such as range and membership predicates.

### Issuance

The issuer's BLS12-381 G2 Stable Key is used to sign the completed message array input containing the octet strings of the issuer protected header and every payload.  The result is a signature octet string that is used as the initial JWP proof value.

In the implementation, the method used to perform the signing is `blsSign({keyPair, [header, payload1, payload2, ...]})` and returns a binary signature value.

### Presentation

The holder must decode the issuer protected header and payload values in order to generate the identical message array that the issuer used.

To generate a presented JWP for a verifier, the holder must use a cryptographic nonce that is provided by that verifier as input.  This nonce MUST be a 32 byte octet string that the verifier generated by a secure RNG.  How this nonce value is communicated to the holder is out of scope of this presentation.  The `nonce` claim in the presentation protected header is used to store the verifier's given nonce value.

The holder also applies selective disclosure preferences by creating an array of indices of which messages in the input array are to be revealed to the verifier.  The revealed indices MUST include the value `0` so that the issuer protected header message is always revealed to the verifier.

The result of creating a proof is an octet string that is used as the presented JWP proof value.

In the implementation, the method used to generate the proof is `blsCreateProof({signedProof, publicKey, [issuer_header, payload1, payload2, ...], presentation_header, [0, 2, ...])`.

### Verification

The verifier decodes the JWP issuer protected header and payload values into a messages array, skipping any non-revealed payloads.  The current BBS implementation embeds the revealed indices into the output proof value so the verification messages array only needs to include the disclosed messages.

In the implementation, the method used to verify the proof is `blsVerifyProof({verifyProof, publicKey, [issuer_header, payload2, ...], presentation_header)`.

### JPA Registration

Proposed JWP `alg` value for BBS based on the software implementation is "BBS-X".

### Example

The following example uses the given BLS12-384 key-pair:

Public:
```json bbs_issuer_public_octets
[140, 129, 17, 222, 243, 162, 119, 27, 26, 140, 2, 19, 111, 52, 124, 84, 132, 226, 125, 34, 35, 174, 46, 18, 156, 26, 144, 78, 178, 236, 114, 2, 237, 148, 150, 47, 201, 102, 49, 0, 177, 147, 47, 81, 169, 243, 155, 226, 4, 77, 164, 83, 41, 123, 36, 31, 181, 111, 82, 110, 247, 214, 70, 239, 81, 35, 160, 254, 79, 82, 38, 211, 46, 194, 244, 181, 81, 149, 40, 130, 89, 26, 117, 43, 183, 208, 173, 175, 181, 244, 13, 120, 30, 163, 133, 84]
```

Private:
```json bbs_issuer_private_octets
[42, 72, 136, 22, 114, 168, 145, 180, 187, 222, 48, 107, 73, 209, 250, 254, 98, 216, 211, 253, 187, 119, 181, 94, 115, 142, 112, 37, 234, 117, 75, 75]
```

The protected header used is:
```json bbs_issuer_protected_header
{
  "iss": "https://issuer.example",
  "claims": [
    "family_name",
    "given_name",
    "email",
    "age"
  ],
  "typ": "JPT",
  "alg": "BBS-X"
}
```

The first payload is the string `"Doe"` with the octet sequence of `[34, 68, 111, 101, 34]` and base64url-encoded as `IkRvZSI`.  

The second payload is the string `"Jay"` with the octet sequence of `[34, 74, 97, 121, 34]` and base64url-encoded as `IkpheSI`.  

The third payload is the string `"jaydoe@example.org"` with the octet sequence of `[34, 106, 97, 121, 100, 111, 101, 64, 101, 120, 97, 109, 112, 108, 101, 46, 111, 114, 103, 34]` and base64url-encoded as `ImpheWRvZUBleGFtcGxlLm9yZyI`.  

The fourth payload is the string `42` with the octet sequence of `[52, 50]` and base64url-encoded as `NDI`.  

The message array used as an input to the BLS implementation is:

```json bbs_issuer_messages
[
 [123, 34, 105, 115, 115, 34, 58, 34, 104, 116, 116, 112, 115, 58, 47, 47, 105, 115, 115, 117, 101, 114, 46, 101, 120, 97, 109, 112, 108, 101, 34, 44, 34, 99, 108, 97, 105, 109, 115, 34, 58, 91, 34, 102, 97, 109, 105, 108, 121, 95, 110, 97, 109, 101, 34, 44, 34, 103, 105, 118, 101, 110, 95, 110, 97, 109, 101, 34, 44, 34, 101, 109, 97, 105, 108, 34, 44, 34, 97, 103, 101, 34, 93, 44, 34, 116, 121, 112, 34, 58, 34, 74, 80, 84, 34, 44, 34, 97, 108, 103, 34, 58, 34, 66, 66, 83, 45, 88, 34, 125],
 [34, 68, 111, 101, 34],
 [34, 74, 97, 121, 34],
 [34, 106, 97, 121, 100, 111, 101, 64, 101, 120, 97, 109, 112, 108, 101, 46, 111, 114, 103, 34],
 [52, 50]
]
```

Using the above inputs, the output of the `blsSign()` call is the octet string:
```json bbs_issuer_signature
[161, 210, 160, 148, 181, 197, 110, 95, 71, 215, 128, 102, 34, 30, 189, 254, 23, 223, 32, 5, 146, 180, 244, 117, 220, 95, 222, 33, 187, 159, 171, 33, 19, 57, 132, 48, 243, 31, 176, 63, 165, 179, 82, 232, 1, 126, 185, 70, 59, 71, 186, 202, 107, 21, 161, 207, 85, 91, 66, 162, 251, 56, 129, 110, 183, 93, 117, 16, 166, 55, 82, 66, 44, 230, 113, 84, 149, 43, 44, 241, 109, 80, 17, 220, 37, 8, 220, 204, 169, 56, 216, 74, 239, 90, 249, 53, 174, 177, 76, 22, 198, 7, 148, 182, 179, 123, 152, 69, 31, 96, 203, 103]
```

The resulting signed JWP in JSON serialization is:
```json bbs_issued_jwp
{
  "protected": "eyJpc3MiOiJodHRwczovL2lzc3Vlci5leGFtcGxlIiwiY2xhaW1zIjpbImZhbWlseV9uYW1lIiwiZ2l2ZW5fbmFtZSIsImVtYWlsIiwiYWdlIl0sInR5cCI6IkpQVCIsImFsZyI6IkJCUy1YIn0",
  "payloads": [
    "IkRvZSI",
    "IkpheSI",
    "ImpheWRvZUBleGFtcGxlLm9yZyI",
    "NDI"
  ],
  "proof": "odKglLXFbl9H14BmIh69_hffIAWStPR13F_eIbufqyETOYQw8x-wP6WzUugBfrlGO0e6ymsVoc9VW0Ki-ziBbrdddRCmN1JCLOZxVJUrLPFtUBHcJQjczKk42ErvWvk1rrFMFsYHlLaze5hFH2DLZw"
}
```

The same JWP in compact serialization:
```text bbs_issued_compact
ImV5SnBjM01pT2lKb2RIUndjem92TDJsemMzVmxjaTVsZUdGdGNHeGxJaXdpWTJ4aGFXMXpJanBiSW1aaGJXbHNlVjl1WVcxbElpd2laMmwyWlc1ZmJtRnRaU0lzSW1WdFlXbHNJaXdpWVdkbElsMHNJblI1Y0NJNklrcFFWQ0lzSW1Gc1p5STZJa0pDVXkxWUluMCI.IkRvZSI~IkpheSI~ImpheWRvZUBleGFtcGxlLm9yZyI~NDI.odKglLXFbl9H14BmIh69_hffIAWStPR13F_eIbufqyETOYQw8x-wP6WzUugBfrlGO0e6ymsVoc9VW0Ki-ziBbrdddRCmN1JCLOZxVJUrLPFtUBHcJQjczKk42ErvWvk1rrFMFsYHlLaze5hFH2DLZw
```

For verification a nonce is needed:
```json bbs_present_nonce
[66, 152, 45, 43, 212, 59, 122, 56, 34, 60, 240, 188, 130, 10, 188, 37, 82, 165, 138, 47, 184, 100, 69, 189, 253, 88, 65, 80, 201, 42, 162, 118]
```

To generate a proof, the `blsCreateProof()` method is used with a revealed indexes array argument of `[0, 2, 4]` and results in the octet string:
```json bbs_present_proof
[0, 5, 21, 168, 16, 247, 161, 85, 133, 66, 233, 151, 131, 236, 206, 160, 107, 246, 136, 112, 227, 72, 3, 19, 169, 243, 110, 156, 51, 245, 105, 155, 33, 175, 48, 164, 181, 226, 118, 175, 113, 157, 225, 98, 80, 244, 171, 142, 137, 0, 58, 167, 252, 36, 58, 37, 15, 16, 241, 136, 106, 252, 89, 20, 30, 206, 3, 62, 74, 56, 249, 48, 167, 60, 225, 210, 148, 160, 100, 47, 46, 136, 61, 205, 163, 105, 21, 33, 136, 220, 203, 37, 69, 187, 184, 63, 196, 46, 43, 165, 178, 212, 238, 214, 179, 29, 24, 220, 151, 170, 148, 166, 242, 173, 90, 195, 152, 61, 159, 88, 199, 195, 62, 170, 96, 181, 97, 155, 135, 176, 175, 20, 191, 7, 252, 138, 107, 54, 231, 238, 103, 49, 90, 80, 193, 27, 137, 0, 0, 0, 116, 146, 156, 218, 93, 80, 118, 105, 79, 134, 149, 90, 108, 215, 170, 106, 33, 234, 150, 229, 74, 253, 2, 114, 80, 100, 30, 82, 65, 242, 141, 210, 18, 101, 150, 18, 226, 54, 147, 35, 69, 75, 158, 62, 161, 20, 191, 182, 108, 0, 0, 0, 2, 7, 107, 154, 12, 90, 222, 64, 186, 16, 95, 51, 31, 126, 43, 151, 52, 226, 7, 201, 232, 154, 67, 169, 228, 86, 211, 202, 12, 233, 222, 160, 180, 32, 237, 4, 201, 153, 190, 35, 114, 210, 66, 99, 122, 75, 216, 62, 30, 59, 177, 164, 14, 147, 164, 123, 176, 67, 43, 242, 12, 173, 67, 108, 93, 173, 203, 96, 121, 60, 54, 143, 88, 253, 62, 156, 96, 104, 136, 20, 122, 124, 53, 127, 151, 217, 111, 154, 234, 137, 127, 144, 149, 173, 44, 119, 82, 43, 75, 60, 69, 1, 243, 232, 154, 253, 67, 94, 220, 127, 182, 27, 186, 0, 0, 0, 4, 103, 10, 114, 139, 49, 98, 199, 34, 114, 64, 103, 64, 234, 150, 191, 77, 10, 110, 35, 159, 38, 31, 224, 231, 152, 192, 196, 66, 85, 110, 87, 86, 81, 154, 242, 157, 107, 191, 124, 177, 27, 89, 216, 123, 88, 219, 141, 215, 132, 200, 82, 249, 45, 212, 254, 254, 161, 38, 98, 107, 20, 43, 205, 88, 79, 117, 222, 186, 89, 10, 23, 180, 51, 18, 238, 144, 69, 255, 41, 61, 210, 12, 176, 57, 11, 56, 222, 200, 193, 128, 3, 234, 154, 202, 13, 43, 89, 114, 105, 229, 10, 170, 6, 156, 243, 152, 177, 254, 248, 238, 13, 172, 153, 121, 254, 33, 248, 48, 109, 118, 86, 81, 41, 131, 204, 71, 117, 242]
```

The resulting verifiable JWP in JSON serialization is:
```json bbs_present_jwp
{
  "protected": "eyJpc3MiOiJodHRwczovL2lzc3Vlci5leGFtcGxlIiwiY2xhaW1zIjpbImZhbWlseV9uYW1lIiwiZ2l2ZW5fbmFtZSIsImVtYWlsIiwiYWdlIl0sInR5cCI6IkpQVCIsImFsZyI6IkJCUy1YIn0",
  "payloads": [
    null,
    "IkpheSI",
    null,
    "NDI"
  ],
  "proof": "AAUVqBD3oVWFQumXg-zOoGv2iHDjSAMTqfNunDP1aZshrzCkteJ2r3Gd4WJQ9KuOiQA6p_wkOiUPEPGIavxZFB7OAz5KOPkwpzzh0pSgZC8uiD3No2kVIYjcyyVFu7g_xC4rpbLU7tazHRjcl6qUpvKtWsOYPZ9Yx8M-qmC1YZuHsK8Uvwf8ims25-5nMVpQwRuJAAAAdJKc2l1QdmlPhpVabNeqaiHqluVK_QJyUGQeUkHyjdISZZYS4jaTI0VLnj6hFL-2bAAAAAIHa5oMWt5AuhBfMx9-K5c04gfJ6JpDqeRW08oM6d6gtCDtBMmZviNy0kJjekvYPh47saQOk6R7sEMr8gytQ2xdrctgeTw2j1j9PpxgaIgUenw1f5fZb5rqiX-Qla0sd1IrSzxFAfPomv1DXtx_thu6AAAABGcKcosxYscickBnQOqWv00KbiOfJh_g55jAxEJVbldWUZrynWu_fLEbWdh7WNuN14TIUvkt1P7-oSZiaxQrzVhPdd66WQoXtDMS7pBF_yk90gywOQs43sjBgAPqmsoNK1lyaeUKqgac85ix_vjuDayZef4h-DBtdlZRKYPMR3Xy"
}
```

The same JWP in compact serialization:
```text bbs_present_compact
ImV5SnBjM01pT2lKb2RIUndjem92TDJsemMzVmxjaTVsZUdGdGNHeGxJaXdpWTJ4aGFXMXpJanBiSW1aaGJXbHNlVjl1WVcxbElpd2laMmwyWlc1ZmJtRnRaU0lzSW1WdFlXbHNJaXdpWVdkbElsMHNJblI1Y0NJNklrcFFWQ0lzSW1Gc1p5STZJa0pDVXkxWUluMCI.~IkpheSI~~NDI.AAUVqBD3oVWFQumXg-zOoGv2iHDjSAMTqfNunDP1aZshrzCkteJ2r3Gd4WJQ9KuOiQA6p_wkOiUPEPGIavxZFB7OAz5KOPkwpzzh0pSgZC8uiD3No2kVIYjcyyVFu7g_xC4rpbLU7tazHRjcl6qUpvKtWsOYPZ9Yx8M-qmC1YZuHsK8Uvwf8ims25-5nMVpQwRuJAAAAdJKc2l1QdmlPhpVabNeqaiHqluVK_QJyUGQeUkHyjdISZZYS4jaTI0VLnj6hFL-2bAAAAAIHa5oMWt5AuhBfMx9-K5c04gfJ6JpDqeRW08oM6d6gtCDtBMmZviNy0kJjekvYPh47saQOk6R7sEMr8gytQ2xdrctgeTw2j1j9PpxgaIgUenw1f5fZb5rqiX-Qla0sd1IrSzxFAfPomv1DXtx_thu6AAAABGcKcosxYscickBnQOqWv00KbiOfJh_g55jAxEJVbldWUZrynWu_fLEbWdh7WNuN14TIUvkt1P7-oSZiaxQrzVhPdd66WQoXtDMS7pBF_yk90gywOQs43sjBgAPqmsoNK1lyaeUKqgac85ix_vjuDayZef4h-DBtdlZRKYPMR3Xy
```

## ZKSnark

TBD

# Security Considerations

* Data minimization of the proof value
* Unlinkability of the protected header contents

# IANA Considerations

## JWP Algorithms Registry

This section establishes the IANA JWP Algorithms Registry.  It also registers the following algorithms.

TBD

{backmatter}

# Acknowledgements

TBD
